---
title: 'nanotatoR: next generation structural variant annotation and classification'
author: "Surajit Bhattacharya,Hayk Barsheghyan, Emmanuele C Delot and Eric Vilain"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{nanotatoR}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction
Short-read sequencing (**SRS**) is the predominant technique of DNA sequencing used for clinical diagnosis. It utilizes flowcells covered with millions of surface-bound oligonucleotides that allow parallel sequencing of hundreds of millions of independent short reads. However, as the average sequencing read length is less than 150 bp, large structural variants (**SVs**) and copy number variants (**CNVs**) are challenging to observe. This creates a diagnostic gap between the clinical phenotypes and the underlying genetic mechanisms in the field of biomedical sciences. Novel technologies such as optical mapping and long-read sequencing have partially addressed the issues of SV and CNV detection; however, the identification of pathogenic variants among thousands of called SVs/CNVs throughout the genome has proven to be challenging as the analytical pipelines available for single nucleotide variants are not applicable to SV analysis. Thus, we have built an R language annotation software package “nanotatoR” specifically for structural variants to provide a multitude of critical functional annotations for large genomic variations.

#Package Installation

**nanotatoR** is currently available from the GitHub repository. Installation method is as follows:
```{r eval=FALSE}
library("devtools")
devtools::install_github("VilainLab/Nanotator")
```

```{r eval=TRUE}
library("nanotatoR")
```

The **nanotatoR** package is compatible with R versions ≥ 3.43.

#Package Functionalities

Given a list of structural variants with chromosome number, SV type, and variant start/end positions, nanotatoR can perform the following functions:

##Structural Variant Frequency

Genomic variant frequencies are one of the most important filtration characteristics for identification of rare, possibly pathogenic, variants. NanotatoR utilizes Database of Genomic Variants (**DGV**), a publically available reference control database, to estimate structural variant frequencies in the general population. Compared with the traditional single nucleotide variant frequency calculations, frequency estimates for structural variants pose larger difficulty due to the much higher breakpoint variability between “same” structural variants. In order to provide accurate estimates of population frequencies, nanotatoR recognizes four categories of SVs: insertions, deletions, inversions and translocations (e.g. “duplications” and/or “gains” are considered as “insertions” and “loss” is considered as “deletion”). Additionally, in order for the SVs to be considered the “same”, nanotatoR, by default, checks whether two independent variants in the same category (e.g. deletion) have greater than 50% size similarity and if the SV breakpoints (start and end positions) are within 10 kbp from each other. Currently the 50% size similarity cutoff is not applied for inversions or translocations as the sizes for these structural variations is not computed by most SV callers; however, nanotatoR implements a breakpoint cutoff of 50 kbp for inversion and translocation calls in order to identify variant frequency. In order for natotatoR to estimate SV frequencies it requires the following input files: DGV reference file(**dgvpath**) and “smap” file containing structural variant information generated via next-generation optical mapping  (**smappath**). The default input parameters for SV breakpoints and percent similarities are as follows: insertions/deletions (**win_indel**) of 10,000 bases, inversions and translocations  (**win_inv_trans**) of 50,000 bases and percentage similarity (**perc_similarity**) of 0.5 or 50%. The output from this function can be of 2 types: an R object (**dataFrame**) or a text file (**Text**) .
```{r eval=TRUE}
smap="F1.1_GM24385_DLE-1_P_trio_hg19.smap"
smappath = system.file("extdata", smap, package="nanotatoR")
hgpath=system.file("extdata", "GRCh37_hg19_variants_2016-05-15.txt", package="nanotatoR")
win_indel_DGV=10000;win_inv_trans_DGV=50000;perc_similarity_DGV=0.5
datDGV<- DGV_extraction (hgpath, smappath,input_fmt_DGV = "Text", smap, 
win_indel_DGV = 10000, win_inv_trans_DGV = 50000,perc_similarity_DGV = 0.5,returnMethod_DGV="dataFrame")
```

##Cohort Analysis

The cohort analysis is designed to provide internal variant frequency, and parental zygosity within the cohort. The function will first merge all of the available individual smaps to form an “internal reference” (**buildSVInternalDB**=*TRUE*) or use an existing file if the internal SV database is already available (**buildSVInternalDB**=*FALSE*). The function requires the paths of the query smap file, the merged internal database file, as well as the following parameters: confidence score threshold for insertion and deletion (**indelconf**; Default is 0.5), inversion (**invconf**; Default is 0.01) and translocation (**transconf**; Default is 0.1). The output can be a (**dataFrame**) or a text file (**Text**).

```{r eval=TRUE}
path <- system.file("extdata", "SoloFile", package="nanotatoR")
pattern="_hg19.smap"
smapName="F1.1_GM24385_DLE-1_P_trio_hg19.smap"
smappath = system.file("extdata", smapName, package="nanotatoR")
intFreq<-internalFrequency(smappath = smappath , buildSVInternalDB = TRUE, soloPath= path, smapName=smapName, solopattern = pattern,outpath = path,input_fmt_INF= "Text",win_indel = 10000,limsize= 1000,win_inv_trans= 50000, perc_similarity = 0.5,indelconf = 0.5, invconf = 0.01 ,transconf = 0.1,returnMethod_Internal = "dataFrame")
intFreq[1:2,]
```

##Gene Overlap 

Incorporates known gene and non-coding RNA genomic locations that overlap with or are near the identified structural variants. NanotatoR automatically determines the number of overlapping genes for a given structural variant, provides the strandedness of the gene (+ or -) as well as the percent overlap of SVs with the gene. The function also provides gene names and corresponding distances from SVs for the nearest genes (user selected, default 3 on each side) that are upstream and downstream.
The function requires an input BED file (**inputfmt**=*BED*) or bionano compliant BED file (**inputfmt**=*BNBED*), which replaces the X and Y chromosome notations to 23 and 24, respectively. The BED files are used to overlap structural variants of the query smap file (**smap**), with overlapping and non-overlapping upstream and down-stream (**n**;default is 3). The output from this function can be of 2 types: an R object (**dataFrame**) or a text file (**Text**).


```{r eval=TRUE}
smapName="F1.1_GM24385_DLE-1_P_trio_hg19.smap"
smap = system.file("extdata", smapName, package="nanotatoR")
bedFile <- system.file("extdata", "Homo_sapiens.Hg19.bed", package="nanotatoR")
outpath <- system.file("extdata",  package="nanotatoR")
datcomp<-compSmapbed(smap, bed=bedFile, inputfmtBed =  "BED", outpath, 
n = 3, returnMethod_bedcomp = c("Text", "dataFrame"))
```

##Entrez Extract

Generates a list of genes involved with the patient’s phenotype and overlaps it with gene names that span structural variants. The user provided, phenotype based key words are used to generate gene lists from selected databases such as ClinVar, OMIM, GTR and Gene Registry. The generated lists are used to prioritize structural variants that occur in genes known to be associated with patient’s phenotype.
The input to the function is a term, which can be provided as a single character input (**method**=“Single”), or a vector of terms (**method**=“Multiple”) or as a text file (**method**=“Text”). The output can be selected as a (**dataFrame**) or a text file (**Text**).

```{r eval=TRUE}
terms="Muscle Weakness"
gene<-gene_list_generation(method="Single", term=terms, 
   	returnMethod_GeneList="dataFrame")
gene[1:10,]
```


##Filter Variants 

Provides easy to use, user-selected, filtration criteria to segregate variants into corresponding groups (such as de novo, inherited or occurring in the gene list). In this step the generated or available gene lists are appended to the smap file.
The input file for this function can either be an  (**smap**) or a dataframe . Both raw and nanotatoR annotated smaps can serve as inputs. It has an option to take the input of the smap (**input_fmt_svMap**) and genelist (**input_fmt_geneList**) as a dataFrame or a text file, and produces an excel as the output.

```{r eval=FALSE}
smapName="F1.1_GM24385_DLE-1_P_trio_hg19.smap"
smappath = system.file("extdata", smapName, package="nanotatoR")
terms="Muscle Weakness"
gene<-gene_list_generation(method="Single", term=terms, 
returnMethod_GeneList="dataFrame")
 run_bionano_filter(SVFile=smappath,fileName,input_fmt_geneList="dataFrame",
    input_fmt_svMap="Text",RtoolsZIPpath="")
```

##Master

The master function consecutively runs the available nanotatoR sub-functions by appending the outputs from each function. 
It takes as an input the smap file, DGV file, BED file, internal database file, phenotype term list as an input. It also takes in the output path and the filename for the final excel file. Individual, sub-function, input parameters are also available for user selections.


```{r eval=FALSE}
terms="Muscle Weakness"
gene<-gene_list_generation(method="Single", term=terms, 
  	returnMethod_GeneList="dataFrame")
smapName="F1.1_GM24385_DLE-1_P_trio_hg19.smap"
smappath = system.file("extdata", smapName, package="nanotatoR")
nanotatoR_main(smap, bed, inputfmtBed = c("BNBED"), 
 n=3,mergedFiles , buildSVInternalDB=TRUE, soloPath, solopattern, 
input_fmt_INF=c("dataframe"),returnMethod_GeneList=c("dataframe"),
returnMethod_bedcomp=c("dataframe"),returnMethod_DGV=c("dataframe"),
returnMethod_Internal=c("dataframe"),input_fmt_DGV=c("dataframe"),	
hgpath, smapName,method=c("Single"), term, thresh=5,
input_fmt_geneList=c("dataframe"),input_fmt_svMap=c("dataframe"),
svData,dat_geneList,outpath="",outputFilename="",RZIPpath="")
```

#References

1.Hayk Barseghyan, Wilson Tang, Richard T. Wang, Miguel Almalvez, Eva Segura, Matthew S. Bramble, Allen Lipson, Emilie D. Douine, Hane Lee, Emmanuèle C. Délot, Stanley F. Nelson and Eric Vilain.Next-generation mapping: a novel approach for detection of pathogenic structural variants with a potential utility in clinical diagnosis. Genome Medicine 2017 9:90. https://doi.org/10.1186/s13073-017-0479-0

2. Winter, D. J.  rentrez: an R package for the NCBI eUtils API The R Journal 2017 9(2):520-526

3. Christopher Brown.  hash: Full feature implementation of hash/associated arrays/dictionaries.2013. R package version 2.2.6. https://CRAN.R-project.org/package=hash

4. Hadley Wickham. stringr: Simple, Consistent Wrappers for Common String Operations. 2018. R package version 1.3.1. https://CRAN.R-project.org/package=stringr

